var emojitracker = (function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function addLoc(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function _differsImmutable(a, b) {
		return a != a ? b == b : a !== b;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._bind = options._bind;

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		this.root._lock = true;
		callAll(this.root._beforecreate);
		callAll(this.root._oncreate);
		callAll(this.root._aftercreate);
		this.root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function removeFromStore() {
		this.store._remove(this);
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_mount,
		_differs
	};

	/* src\emojitracker.html generated by Svelte v2.9.5 */

	function oncreate() {
	    console.log("Hello, world.");
	}
	const file = "src\\emojitracker.html";

	function create_main_fragment(component, ctx) {
		var div, text, text_1, each_anchor;

		var each_value = ctx.$ids;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		var each_else = null;

		if (!each_value.length) {
			each_else = create_each_block_else(component, ctx);
			each_else.c();
		}

		return {
			c: function create() {
				div = createElement("div");
				text = createText("😁😁😁");
				text_1 = createText("\r\n\r\n");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				addLoc(div, file, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(text, div);
				insertNode(text_1, target, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insertNode(each_anchor, target, anchor);

				if (each_else) {
					each_else.m(target, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$data || changed.$ids) {
					each_value = ctx.$ids;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (each_value.length) {
					if (each_else) {
						each_else.d(1);
						each_else = null;
					}
				} else if (!each_else) {
					each_else = create_each_block_else(component, ctx);
					each_else.c();
					each_else.m(each_anchor.parentNode, each_anchor);
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
					detachNode(text_1);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}

				if (each_else) each_else.d(detach);
			}
		};
	}

	// (3:0) {#each $ids as id}
	function create_each_block(component, ctx) {
		var div, pre, text_value = ctx.$data[ctx.id].char, text, text_1, text_2_value = ctx.$data[ctx.id].score, text_2;

		return {
			c: function create() {
				div = createElement("div");
				pre = createElement("pre");
				text = createText(text_value);
				text_1 = createText(" - ");
				text_2 = createText(text_2_value);
				addLoc(pre, file, 4, 8, 60);
				addLoc(div, file, 3, 4, 45);
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(pre, div);
				appendNode(text, pre);
				appendNode(text_1, pre);
				appendNode(text_2, pre);
			},

			p: function update(changed, ctx) {
				if ((changed.$data || changed.$ids) && text_value !== (text_value = ctx.$data[ctx.id].char)) {
					text.data = text_value;
				}

				if ((changed.$data || changed.$ids) && text_2_value !== (text_2_value = ctx.$data[ctx.id].score)) {
					text_2.data = text_2_value;
				}
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (7:0) {:else}
	function create_each_block_else(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("No emojis loaded yet, hang on!");
			},

			m: function mount(target, anchor) {
				insertNode(text, target, anchor);
			},

			d: function destroy$$1(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.id = list[i];
		child_ctx.each_value = list;
		child_ctx.id_index = i;
		return child_ctx;
	}

	function Emojitracker(options) {
		this._debugName = '<Emojitracker>';
		if (!options || (!options.target && !options.root)) throw new Error("'target' is a required option");
		init(this, options);
		this._state = assign(this.store._init(["ids","data"]), options.data);
		this.store._add(this, ["ids","data"]);
		if (!('$ids' in this._state)) console.warn("<Emojitracker> was created without expected data property '$ids'");
		if (!('$data' in this._state)) console.warn("<Emojitracker> was created without expected data property '$data'");
		this._intro = true;

		this._handlers.destroy = [removeFromStore];

		if (!options.root) {
			this._oncreate = [];
		}

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			callAll(this._oncreate);
		}
	}

	assign(Emojitracker.prototype, protoDev);

	Emojitracker.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	var emojitracker = /*#__PURE__*/Object.freeze({
		default: Emojitracker
	});

	function Store(state, options) {
		this._handlers = {};
		this._dependents = [];

		this._computed = blankObject();
		this._sortedComputedProperties = [];

		this._state = assign({}, state);
		this._differs = options && options.immutable ? _differsImmutable : _differs;
	}

	assign(Store.prototype, {
		_add(component, props) {
			this._dependents.push({
				component: component,
				props: props
			});
		},

		_init(props) {
			const state = {};
			for (let i = 0; i < props.length; i += 1) {
				const prop = props[i];
				state['$' + prop] = this._state[prop];
			}
			return state;
		},

		_remove(component) {
			let i = this._dependents.length;
			while (i--) {
				if (this._dependents[i].component === component) {
					this._dependents.splice(i, 1);
					return;
				}
			}
		},

		_set(newState, changed) {
			const previous = this._state;
			this._state = assign(assign({}, previous), newState);

			for (let i = 0; i < this._sortedComputedProperties.length; i += 1) {
				this._sortedComputedProperties[i].update(this._state, changed);
			}

			this.fire('state', {
				changed,
				previous,
				current: this._state
			});

			const dependents = this._dependents.slice(); // guard against mutations
			for (let i = 0; i < dependents.length; i += 1) {
				const dependent = dependents[i];
				const componentState = {};
				let dirty = false;

				for (let j = 0; j < dependent.props.length; j += 1) {
					const prop = dependent.props[j];
					if (prop in changed) {
						componentState['$' + prop] = this._state[prop];
						dirty = true;
					}
				}

				if (dirty) dependent.component.set(componentState);
			}

			this.fire('update', {
				changed,
				previous,
				current: this._state
			});
		},

		_sortComputedProperties() {
			const computed = this._computed;
			const sorted = this._sortedComputedProperties = [];
			const visited = blankObject();
			let currentKey;

			function visit(key) {
				const c = computed[key];

				if (c) {
					c.deps.forEach(dep => {
						if (dep === currentKey) {
							throw new Error(`Cyclical dependency detected between ${dep} <-> ${key}`);
						}

						visit(dep);
					});

					if (!visited[key]) {
						visited[key] = true;
						sorted.push(c);
					}
				}
			}

			for (const key in this._computed) {
				visit(currentKey = key);
			}
		},

		compute(key, deps, fn) {
			let value;

			const c = {
				deps,
				update: (state, changed, dirty) => {
					const values = deps.map(dep => {
						if (dep in changed) dirty = true;
						return state[dep];
					});

					if (dirty) {
						const newValue = fn.apply(null, values);
						if (this._differs(newValue, value)) {
							value = newValue;
							changed[key] = true;
							state[key] = value;
						}
					}
				}
			};

			this._computed[key] = c;
			this._sortComputedProperties();

			const state = assign({}, this._state);
			const changed = {};
			c.update(state, changed, true);
			this._set(state, changed);
		},

		fire,

		get,

		on,

		set(newState) {
			const oldState = this._state;
			const changed = this._changed = {};
			let dirty = false;

			for (const key in newState) {
				if (this._computed[key]) throw new Error(`'${key}' is a read-only property`);
				if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
			}
			if (!dirty) return;

			this._set(newState, changed);
		}
	});

	const store = new Store({
	    ids  : [],
	    data : Object.create(null),
	});

	// Get initial data & then set up stream
	(async function() {
	    const response = await fetch("https://api.emojitracker.com/v1/rankings");
	    const json = await response.json();

	    const { ids, data } = store.get();

	    json.forEach((emoji) => {
	        const { id } = emoji;

	        data[id] = emoji;
	        ids.push(id);
	    });

	    store.set({
	        data,
	        ids,
	    });

	    const stream = new EventSource("https://stream.emojitracker.com/subscribe/eps");

	    stream.onmessage = (msg) => {
	        const updates = JSON.parse(msg.data);

	        const { data } = store.get();

	        Object.entries(updates).forEach(([ key, value ]) => {
	            data[key].score += value;
	        });

	        store.set({ data });
	    };
	}());

	var emojitracker_store = /*#__PURE__*/Object.freeze({
		default: store
	});

	var EmojiTracker = ( emojitracker && Emojitracker ) || emojitracker;

	var store$1 = ( emojitracker_store && store ) || emojitracker_store;

	new EmojiTracker({
	    target : document.body,
	    store: store$1,
	});

	var src = {

	};

	return src;

}());
